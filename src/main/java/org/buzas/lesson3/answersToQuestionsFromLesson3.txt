Отсутствовал на уроке из-за личных обстоятельств. Но так как весь урок, по большей части, проходит в формате вопрос-ответ - скачал урок и ответил на все вопросы
 по порядку
UPD. Знаю, что есть txt-файл, но, посмотрев в него увидел, что некоторые части вопросов с урока были опущены или перенесены в другое место.
Заменил цифры под каждым вопросов под цифры вопросов из txt-файла, а промежуточные вопросы внутри отметил знаком *(n -при переносе вопроса).
1.
*JDK - набор средств разработки на Java
JVM - виртуальная машина джава
JRE - среда выполнения Java, т.е. всё, что нужно для запуска Java-программа
*Связь: с помощью JDK создаем, с помощью JVM компилируем, с помощью JRE запускаем
2.
*Кажется называется "последний зашел- первый вышел"
Состоит из кучи и стека
В куче хранятся объекты. Она является основным сегментом памяти
*Стэк как раз использует принцип названный в начале. Когда используется любой метод из любого класса, для него создается новый блок в памяти,
последний содержит примитивы и ссылки на другие объекты. После работы метода блок освобождается. Стэк значительно меньше кучи. Можно сказать, что стэк - это
своеобразная оперативная память.
*При заполнении стэка - stack overflow. При заполнении кучи- не помню, но предположу что-то связанное со словом heap
3.
*Не знаю, но скорее всего для какой-то второстепенной информации вроде кэша
4/пропавший 5.
*Не знаю
6.
*Garbage collector- автоматическая система, переодически удаляющая из памяти не использующиеся данные, тем самым освобождая память под новые
*(8)Stop the world- полная остановка программы для безопасной сборки мусора
*Не знаю, предположение от ответов других участников ранее: old и new generation. Old - объекты, необходимые для работы программы и долгоживущие объекты,
 new - остальные, маложивущие объекты
*Жизненный цикл объекта: создание с помощью оператора new, существует пока на него есть ссылки, удаляется с помощью GC
7.
*Не знаю
9.
*Точно не знаю, но логично, что если на объект нет ссылок и нет логики, чтобы использовать его позже, то он лежит на удаление.
10.
*happens before - это отношение между командами при котором вторая команда будет в курсе изменений в первой. При этом все значения первого должны быть заданы
раньше второго действия
11.
*volatile используется для изменения значения переменной различными потоками в потокобезопасном режиме
*1) создать класс с extends Thread и переопределить методы
 2) созать класс с implements runnable
 3) new Thread
12.
*Пул потоков- контейнер с потоками, которые могут выполнить задачи, а затем самостоятельно перейти к выполнению следующей
Нужен потому, что создание потоков- дорогостоющие операции. Создание пулов потоков позволяет экономить ресурсы, создавая потоки
лишь единожды
Из плюсов пула потоков можно выделить высокую производительность, экономию времени и легкий доступ.
13.
*Монитор блокировки - объект, который не позволяет влажеть одним объектом множеству потоков одновременно
14.
*Монитором блокировки может быть любой объект.
15.
*synchronized используется для блокировки доступа к методу или переменной, если её уже использует любой поток
16.
*wait()- освобождает монитор и переводит поток в ожидание до вызова notify()
notify()- продолжает работу потока, у которого вызвали метод wait()
notifyAll()- продолжает работу всех остановленных потоков
17.
*Поток-демон - это поток, который работает на "заднем фоне" программы. Т.е. от момента запуска до логического завершения работы потока или завершения всей программы,
в которой данный поток был запущен. Потоки можно переключить в состояние потока-демона и обратно методом isDaemon в любой момент
18.
*1) создать boolean-переменную в потоке и создать метод, который меняет значение флага. Затем в методе run() сделать цикл while(флаг).
 В нужный момент в остальном коде отключить поток с помощью метода. В таком случае работу можно будет продолжить применив метод еще раз
2) метод interrupt(). В целом можно задать схожую логику с п.1, т.к. в потоках изначально не только существует interrupt(), но и isInterrupted(),
 который можно использовать как while(!isInterrupted()).
3) stop() "убьет" процесс. Документация говорит, что использовать данный метод не стоит, т.к. убитый процесс оставит часть кода измененной не до конца и
 никогда не сможет закончить начатую работу. Но, если в этом есть потребность, такой функционал тоже существует.
*Deadlock - взаимная блокировка, когда двум потокам нужны одинаковые блокировки, но они получают их в разнобой. К примеру, всем потокам нужен доступ к одному из
 мониторов, которые уже используются другими потоками
*Избежать взаимной блокировки можно создав метод, проверяющий код на deadlock, к примеру с помощью
 if(threadA.isLock){if(threadB.isLock){код для вывода из блокировки}}
*В java.util.concurrent входят классы и интерфейсы для работы с многопоточностью
пропавший 19.
У каждого класса Thread есть таблица переменных, захваченных потоком. Т.е. если отправить переменную A, то в потоке будет своя переменная A,
 захваченная потоком, которая может отличаться от первой A. Их можно изменять с помощью get() и set(). Переменная A, захваченная потоком и является ThreadLocal